#include <SPI.h>
#include <SD.h>

String buffer;
float route_array[3];
File myFile;

#include <AFMotor.h>
#include <Servo.h>
const int stepsPerRevolution = 200; //depends on the motor you are using

// connect motor to port #1(M1 and M2) and #2 (M3 and M4)
AF_Stepper motor1(stepsPerRevolution, 1);
AF_Stepper motor2(stepsPerRevolution, 2);

//create servo object to control a servo
Servo servo1;
int servoWritingPos = 120;
int servoPassingPos = 80;
#define  WRITING  0
#define  PASSING  1

float A = 166; //frame width (cm)
float B = 106; //frame height (cm)
float c = 12.5; //box width (cm)
float d = 4.5; 
const float pi = 3.1415926535898;

void toggleServo(int currentState){
  if(currentState == WRITING){
    for(int i = servoWritingPos; i >= servoPassingPos; i--){
      servo1.write(i);
      delay(25);
    }
  }else{
    for(int i = servoPassingPos; i <= servoWritingPos; i++){
      servo1.write(i);
      delay(25);
    }
  }
}
float returnsX(float A, float c, float L1, float L2)
{
  float x = (L1*L1 - L2*L2 - A*A + A*c)/(c-A)/2;
  return x;
}

float returnsY(float A, float B, float c, float d, float L1, float L2)
{
  float x = (L1*L1 - L2*L2 - A*A + A*c)/(c-A)/2;
  float y = B - d - sqrt(L2*L2 - (x-c/2)*(x-c/2));
  return y;
}

float returnsL1(float x, float y, float A, float B, float c, float d)
{
    float L1squared;
    float L1;
    L1squared = (B - y - d)*(B - y - d) + (A - x - c/2)*(A - x - c/2);
    L1 = sqrt(L1squared);
    return L1;
}

float returnsL2(float x, float y, float A, float B, float c, float d)
{
    float L2squared;
    float L2;
    L2squared = (B - y - d)*(B - y - d) + (x - c/2)*(x - c/2);
    L2 = sqrt(L2squared);
    return L2;  
}
void setup()
{
  delay(5000);
  Serial.begin(9600);  
  motor1.setSpeed(50 );  // 10 rpm   
  motor2.setSpeed(50);

  servo1.attach(10);
    
  float direction1;
  float direction2;
    
  float t = 1; //1 second takes to move 1 unit
  float r = 0.5;//cm

  //starting point 
  float x_start = 60;//cm
  float y_start = 15;//cm 

  //route arry determines the shape we are about to draw
  //for testing we set it manually
  //{x, y}
  //int array_size = 10;
  
 
//DAneshkade,131
  //float route_array[array_size][3] = {{100.25,45.0,0},{100.25,44.75,0},{100.25,44.5,0},{100.5,44.25,1},{100.75,44.0,1},{100.5,43.75,1},{100.25,43.5,1},{100.0,43.5,0},{99.75,43.5,0},{99.75,43.5,1},{99.75,43.75,1},{99.75,44.0,1},{99.75,44.25,1},{99.75,44.5,1},{99.75,44.75,1},{99.75,45.0,1},{99.75,45.25,1},{99.75,45.0,0},{99.75,44.75,0},{99.75,44.5,0},{99.5,44.25,0},{99.25,44.0,0},{99.25,44.0,1},{99.25,43.75,1},{99.25,43.5,1},{99.0,43.5,1},{98.75,43.5,1},{98.5,43.5,1},{98.25,43.5,1},{98.0,43.5,1},{97.75,43.5,1},{97.5,43.5,1},{97.25,43.5,1},{97.0,43.5,1},{96.75,43.5,1},{96.5,43.5,1},{96.25,43.5,1},{96.0,43.5,1},{95.75,43.5,1},{95.5,43.5,1},{95.25,43.5,1},{95.5,43.5,0},{95.75,43.75,0},{95.75,43.75,1},{95.5,44.0,1},{95.25,44.25,1},{95.5,44.25,0},{95.75,44.25,0},{96.0,44.25,0},{96.25,44.0,0},{96.5,43.75,0},{96.5,43.75,1},{96.5,44.0,1},{96.5,44.25,1},{96.5,44.5,1},{96.5,44.75,1},{96.5,45.0,1},{96.75,45.25,1},{97.0,45.5,1},{97.25,45.75,1},{97.5,46.0,1},{97.75,46.25,1},{98.0,46.5,1},{98.0,46.25,0},{98.0,46.0,0},{98.0,45.75,0},{98.0,45.5,0},{98.0,45.25,0},{98.0,45.0,0},{98.0,44.75,0},{98.0,44.5,0},{98.0,44.25,0},{97.75,44.0,0},{97.75,44.0,1},{97.75,43.75,1},{97.5,43.75,0},{97.25,43.75,0},{97.25,43.75,1},{97.25,44.0,1},{97.5,44.0,0},{97.75,44.0,0},{98.0,44.0,0},{98.25,44.0,0},{98.25,44.0,1},{98.25,43.75,1},{98.0,43.75,0},{97.75,43.75,0},{97.5,43.75,0},{97.25,43.75,0},{97.0,43.75,0},{96.75,43.75,0},{96.5,43.75,0},{96.25,43.75,0},{96.0,43.75,0},{95.75,43.75,0},{95.5,43.75,0},{95.25,43.75,0},{95.0,43.75,0},{94.75,43.5,0},{94.75,43.5,1},{94.5,43.5,1},{94.25,43.5,1},{94.25,43.75,1},{94.25,44.0,1},{94.25,44.25,1},{94.5,44.25,1},{94.75,44.25,1},{94.75,44.0,1},{94.75,43.75,1},{95.0,43.75,0},{95.25,43.75,0},{95.5,43.75,0},{95.75,43.75,0},{96.0,43.75,0},{96.25,43.75,0},{96.5,43.75,0},{96.75,43.75,0},{97.0,44.0,0},{97.25,44.25,0},{97.5,44.5,0},{97.5,44.5,1},{97.5,44.75,0},{97.75,45.0,0},{97.75,45.0,1},{97.75,44.75,0},{98.0,44.5,0},{98.0,44.5,1},{98.25,44.5,0},{98.5,44.5,0},{98.75,44.5,0},{98.75,44.5,1}};


//ESLAB,482
  //uint8_t route_array[array_size][3]={{83.25,56.0,0},{83.25,55.75,0},{83.25,55.5,0},{83.0,55.5,1},{82.75,55.5,1},{82.5,55.5,1},{82.25,55.5,1},{82.0,55.5,1},{81.75,55.5,1},{81.5,55.5,1},{81.25,55.5,1},{81.0,55.5,1},{80.75,55.5,1},{80.5,55.5,1},{80.25,55.5,1},{80.0,55.5,1},{79.75,55.5,1},{79.75,55.25,1},{79.75,55.0,1},{79.75,54.75,1},{79.75,54.5,1},{79.75,54.25,1},{79.75,54.0,1},{79.75,53.75,1},{79.75,53.5,1},{79.75,53.25,1},{79.75,53.0,1},{79.75,52.75,1},{79.75,52.5,1},{79.75,52.25,1},{79.75,52.0,1},{79.75,51.75,1},{79.75,51.5,1},{79.75,51.25,1},{79.75,51.0,1},{79.75,50.75,1},{79.75,50.5,1},{79.75,50.25,1},{79.75,50.0,1},{79.75,49.75,1},{79.75,49.5,1},{79.75,49.25,1},{79.75,49.0,1},{79.75,48.75,1},{79.75,48.5,1},{79.75,48.25,1},{79.75,48.0,1},{79.75,47.75,1},{80.0,47.75,1},{80.25,47.75,1},{80.5,47.75,1},{80.75,47.75,1},{81.0,47.75,1},{81.25,47.75,1},{81.5,47.75,1},{81.75,47.75,1},{82.0,47.75,1},{82.25,47.75,1},{82.5,47.75,1},{82.75,47.75,1},{83.0,47.75,1},{83.25,47.75,1},{83.5,47.75,1},{83.75,47.75,0},{84.0,47.75,0},{84.25,47.75,0},{84.5,47.75,0},{84.75,47.75,0},{85.0,47.75,0},{85.25,47.75,0},{85.5,47.75,0},{85.75,47.75,0},{86.0,47.75,0},{86.25,48.0,0},{86.5,48.25,0},{86.5,48.25,1},{86.75,48.0,1},{87.0,47.75,1},{87.25,47.5,1},{87.5,47.5,1},{87.75,47.5,1},{88.0,47.5,1},{88.25,47.5,1},{88.5,47.5,1},{88.75,47.5,1},{89.0,47.5,1},{89.25,47.5,1},{89.5,47.75,1},{89.75,47.75,1},{90.0,48.0,1},{90.0,48.25,1},{90.25,48.5,1},{90.25,48.75,1},{90.5,49.0,1},{90.75,49.25,1},{90.75,49.5,1},{90.5,49.75,1},{90.5,50.0,1},{90.5,50.25,1},{90.25,50.5,1},{90.25,50.75,1},{90.0,51.0,1},{89.75,51.25,1},{89.5,51.5,1},{89.25,51.75,1},{89.0,51.75,1},{88.75,52.0,1},{88.5,52.0,1},{88.25,52.0,1},{88.0,52.0,1},{87.75,52.0,1},{87.5,52.0,1},{87.25,52.0,1},{87.0,52.25,1},{86.75,52.25,1},{86.5,52.5,1},{86.25,52.75,1},{86.25,53.0,1},{86.25,53.25,1},{86.25,53.5,1},{86.25,53.75,1},{86.25,54.0,1},{86.5,54.25,1},{86.5,54.5,1},{86.75,54.75,1},{87.0,55.0,1},{87.25,55.0,1},{87.5,55.25,1},{87.75,55.5,1},{88.0,55.75,1},{88.25,55.75,1},{88.5,55.75,1},{88.75,55.5,1},{89.0,55.5,1},{89.25,55.5,1},{89.5,55.25,1},{89.75,55.0,1},{90.0,55.0,0},{90.25,55.0,0},{90.5,55.0,0},{90.75,55.0,0},{91.0,55.0,0},{91.25,55.0,0},{91.5,55.0,0},{91.75,55.25,0},{92.0,55.5,0},{92.25,55.75,0},{92.25,55.75,1},{92.25,55.5,1},{92.25,55.25,1},{92.25,55.0,1},{92.25,54.75,1},{92.25,54.5,1},{92.25,54.25,1},{92.25,54.0,1},{92.25,53.75,1},{92.25,53.5,1},{92.25,53.25,1},{92.25,53.0,1},{92.25,52.75,1},{92.25,52.5,1},{92.25,52.25,1},{92.25,52.0,1},{92.25,51.75,1},{92.25,51.5,1},{92.25,51.25,1},{92.25,51.0,1},{92.25,50.75,1},{92.25,50.5,1},{92.25,50.25,1},{92.25,50.0,1},{92.25,49.75,1},{92.25,49.5,1},{92.25,49.25,1},{92.25,49.0,1},{92.25,48.75,1},{92.25,48.5,1},{92.25,48.25,1},{92.25,48.0,1},{92.5,48.0,1},{92.75,48.0,1},{93.0,48.0,1},{93.25,48.0,1},{93.5,48.0,1},{93.75,48.0,1},{94.0,48.0,1},{94.25,48.0,1},{94.5,48.0,1},{94.75,48.0,1},{95.0,48.0,1},{95.25,48.0,1},{95.5,48.0,1},{95.75,48.0,1},{96.0,48.0,1},{96.25,48.0,0},{96.5,48.0,0},{96.75,48.0,0},{97.0,48.0,0},{97.25,48.0,0},{97.5,48.0,0},{97.5,48.0,1},{97.5,48.25,1},{97.5,48.5,1},{97.5,48.75,1},{97.5,49.0,1},{97.5,49.25,1},{97.5,49.5,1},{97.5,49.75,1},{97.5,50.0,1},{97.5,50.25,1},{97.5,50.5,1},{97.75,50.75,1},{97.75,51.0,1},{97.75,51.25,1},{97.75,51.5,1},{97.75,51.75,1},{98.0,52.0,1},{98.0,52.25,1},{98.0,52.5,1},{98.0,52.75,1},{98.25,53.0,1},{98.25,53.25,1},{98.25,53.5,1},{98.25,53.75,1},{98.25,54.0,1},{98.25,54.25,1},{98.25,54.5,1},{98.5,54.75,1},{98.5,55.0,1},{98.5,55.25,1},{98.75,55.5,1},{98.75,55.75,1},{98.75,56.0,1},{99.0,56.25,1},{99.25,56.25,1},{99.5,56.0,1},{99.75,55.75,1},{99.75,55.5,1},{100.0,55.25,1},{100.0,55.0,1},{100.25,54.75,1},{100.25,54.5,1},{100.25,54.25,1},{100.25,54.0,1},{100.5,53.75,1},{100.5,53.5,1},{100.5,53.25,1},{100.5,53.0,1},{100.5,52.75,1},{100.75,52.5,1},{100.75,52.25,1},{100.75,52.0,1},{100.75,51.75,1},{100.75,51.5,1},{100.75,51.25,1},{100.75,51.0,1},{101.0,50.75,1},{101.0,50.5,1},{101.0,50.25,1},{101.0,50.0,1},{101.0,49.75,1},{101.25,49.5,1},{101.25,49.25,1},{101.25,49.0,1},{101.25,48.75,1},{101.25,48.5,1},{101.25,48.25,1},{101.25,48.0,1},{101.5,48.0,0},{101.75,48.0,0},{102.0,48.0,0},{102.25,48.0,0},{102.5,48.0,0},{102.75,48.0,0},{103.0,48.0,0},{103.25,48.0,0},{103.5,48.0,0},{103.5,48.0,1},{103.5,48.25,1},{103.5,48.5,1},{103.5,48.75,1},{103.5,49.0,1},{103.5,49.25,1},{103.5,49.5,1},{103.5,49.75,1},{103.5,50.0,1},{103.5,50.25,1},{103.5,50.5,1},{103.5,50.75,1},{103.5,51.0,1},{103.5,51.25,1},{103.5,51.5,1},{103.5,51.75,1},{103.5,52.0,1},{103.5,52.25,1},{103.5,52.5,1},{103.5,52.75,1},{103.5,53.0,1},{103.5,53.25,1},{103.5,53.5,1},{103.5,53.75,1},{103.5,54.0,1},{103.5,54.25,1},{103.5,54.5,1},{103.5,54.75,1},{103.5,55.0,1},{103.5,55.25,1},{103.5,55.5,1},{103.5,55.75,1},{103.5,56.0,1},{103.5,56.25,1},{103.5,56.5,1},{103.75,56.5,1},{104.0,56.75,1},{104.25,56.75,1},{104.5,56.75,1},{104.75,56.75,1},{105.0,56.75,1},{105.25,56.5,1},{105.5,56.25,1},{105.75,56.0,1},{105.75,55.75,1},{105.75,55.5,1},{105.75,55.25,1},{106.0,55.0,1},{106.0,54.75,1},{105.75,54.5,1},{105.75,54.25,1},{105.5,54.0,1},{105.25,53.75,1},{105.0,53.5,1},{104.75,53.25,1},{104.5,53.0,1},{104.25,53.0,1},{104.0,53.0,1},{103.75,53.0,1},{104.0,53.0,0},{104.25,53.25,0},{104.25,53.25,1},{104.5,53.25,1},{104.75,53.0,1},{105.0,53.0,1},{105.25,53.0,1},{105.5,53.0,1},{105.75,53.0,1},{106.0,52.75,1},{106.25,52.75,1},{106.5,52.5,1},{106.75,52.5,1},{107.0,52.25,1},{107.25,52.25,1},{107.5,52.0,1},{107.75,51.75,1},{108.0,51.5,1},{108.0,51.25,1},{108.0,51.0,1},{108.0,50.75,1},{108.25,50.5,1},{108.25,50.25,1},{108.25,50.0,1},{108.25,49.75,1},{108.25,49.5,1},{108.0,49.25,1},{108.0,49.0,1},{108.0,48.75,1},{107.75,48.5,1},{107.5,48.25,1},{107.25,48.0,1},{107.0,47.75,1},{106.75,47.75,1},{106.5,47.5,1},{106.25,47.5,1},{106.0,47.5,1},{105.75,47.5,1},{105.5,47.5,1},{105.25,47.5,1},{105.0,47.75,1},{104.75,47.75,1},{104.5,47.75,1},{104.25,47.75,1},{104.0,47.75,1},{104.0,48.0,0},{104.0,48.25,0},{104.0,48.5,0},{103.75,48.75,0},{103.5,49.0,0},{103.25,49.25,0},{103.0,49.5,0},{102.75,49.75,0},{102.5,50.0,0},{102.25,50.25,0},{102.0,50.5,0},{101.75,50.75,0},{101.5,51.0,0},{101.25,51.25,0},{101.0,51.5,0},{100.75,51.75,0},{100.5,52.0,0},{100.5,52.0,1},{100.25,52.0,1},{100.0,52.0,1},{99.75,52.0,1},{99.5,52.0,1},{99.25,52.0,1},{99.0,52.0,1},{98.75,52.0,1},{98.5,52.0,1},{98.25,52.0,1},{98.0,51.75,1},{97.75,51.75,0},{97.5,51.75,0},{97.25,51.75,0},{97.0,51.75,0},{96.75,51.75,0},{96.5,51.75,0},{96.25,51.75,0},{96.0,51.75,0},{95.75,51.75,0},{95.5,51.75,0},{95.25,51.75,0},{95.0,51.75,0},{94.75,51.75,0},{94.5,51.75,0},{94.25,51.75,0},{94.0,51.75,0},{93.75,51.75,0},{93.5,51.75,0},{93.25,51.75,0},{93.0,51.75,0},{92.75,51.75,0},{92.5,51.75,0},{92.25,51.75,0},{92.0,51.75,0},{91.75,51.75,0},{91.5,51.75,0},{91.25,51.75,0},{91.0,51.75,0},{90.75,51.75,0},{90.5,51.75,0},{90.25,51.75,0},{90.0,51.75,0},{89.75,51.75,0},{89.5,51.75,0},{89.25,51.75,0},{89.0,51.75,0},{88.75,51.75,0},{88.5,51.75,0},{88.25,51.75,0},{88.0,51.75,0},{87.75,51.75,0},{87.5,51.75,0},{87.25,51.75,0},{87.0,51.75,0},{86.75,51.75,0},{86.5,51.75,0},{86.25,51.75,0},{86.0,51.75,0},{85.75,51.75,0},{85.5,51.75,0},{85.25,51.75,0},{85.0,51.75,0},{84.75,51.75,0},{84.5,51.75,0},{84.25,51.75,0},{84.0,51.75,0},{83.75,51.75,0},{83.5,51.75,0},{83.25,51.75,0},{83.0,51.75,0},{83.0,51.75,1},{82.75,51.75,1},{82.5,51.75,1},{82.25,51.75,1},{82.0,51.75,1},{81.75,51.75,1},{81.5,51.75,1},{81.25,51.75,1},{81.0,51.75,1},{80.75,51.75,1},{80.5,51.75,1},{80.25,51.75,1},{80.0,51.75,1}};

//L,486
  //uint8_t route_array[array_size][3]={{86.5,56.25,0},{86.5,56.0,0},{86.5,55.75,1},{86.5,55.5,1},{86.5,55.25,1},{86.5,55.0,1},{86.5,54.75,1},{86.5,54.5,1},{86.5,54.25,1},{86.5,54.0,1}};
  
  int i,j;

  float x = x_start;
  float y = y_start;
  float x_prime, y_prime;
  float L1, L2, L1_prime, L2_prime;
  int lastServoState = PASSING;

//microSD====================================================================

while (!Serial) {
; // wait for serial port to connect. Needed for native USB port only
}
Serial.print("Initializing SD card...");
if (!SD.begin(53)) {
Serial.println("initialization failed!");
while (1);
}
Serial.println("initialization done.");
// open the file for reading:
myFile = SD.open("elow.txt");
if (myFile) {
Serial.println("test.txt:");
// read from the file until there's nothing else in it:
//microSD====================================================================
  int count = 1;
  while (myFile.available()) 
  {
    //microSD====================================================================
    //reading data from the sd

    for(int i = 0;i<3;i++){
    buffer = myFile.readStringUntil(',');
    route_array[i]= buffer.toFloat();
    //Serial.println(route_array[i]);
    
//    if (route_array[0] == 0)
//    {
//      Serial.println("Oooooooooooooooooooooooooooooooooooops!");
//      Serial.println(count);
//      break;
//    }
//println("the route_array is: ");
//println(route_array[i]);
    
    //Printing for debugging purpose         
    //do some action here

}
//count += 1;
// Serial.println(count);

//microSD====================================================================

    
    if(route_array[2] != lastServoState){
      toggleServo(lastServoState);
      lastServoState = route_array[2];
    }
    
    //Serial.println("Starting from:");
    //Serial.print("x=");
    //Serial.println(x);
    //Serial.print("y=");
    //Serial.println(y);
    
    L1 = returnsL1(x, y, A, B, c, d);
    L2 = returnsL2(x, y, A, B, c, d);

    //Serial.print("L1=");
    //Serial.println(L1);
    //Serial.print("L2=");
    //Serial.println(L2);

    x_prime = route_array[0];
    y_prime = route_array[1];

    //Serial.println("Going to:");
    //Serial.print("x'=");
    //Serial.println(x_prime);
    //Serial.print("y'=");
    //Serial.println(y_prime);
    
    L1_prime = returnsL1(x_prime, y_prime, A, B, c, d);
    L2_prime = returnsL2(x_prime, y_prime, A, B, c, d);
    
    //Serial.print("L1_prime=");
    //Serial.println(L1_prime);
    //Serial.print("L2_prime=");
    //Serial.println(L2_prime);
    
    float W1 = (L1_prime - L1)/t;  //(L1'-L1)/delta(t) //cm/sec
    float W2 = (L2_prime - L2)/t; //(L2'-L2)/delta(t); //delta(t) = 2 sec

    float max_W1_W2;
    float min_W1_W2;

    float d1, d2;

    if (W1>0 && W2>0)
    {
      direction1 = FORWARD;
      direction2 = FORWARD;

      d1 = 1;
      d2 = 1; 
    }
    
    else if(W1<0 && W2<0)
    {
      direction1 = BACKWARD;
      direction2 = BACKWARD;

      d1 = -1;
      d2 = -1;
    }
    
    else if (W1>0 && W2<0)
    {
      direction1 = FORWARD;
      direction2 = BACKWARD;
      
      d1 = 1;
      d2 = -1;  
    }
    else if (W1<0 && W2>0)
    {
      direction1 = BACKWARD;
      direction2 = FORWARD;

      d1 = -1;
      d2 = 1;
    }
    
    max_W1_W2 = max(abs(W1), abs(W2));
    min_W1_W2 = min(abs(W1), abs(W2));
    
    //driving motors and moving to a certain point 
    float alpha = abs(max_W1_W2/min_W1_W2);
    float n_min = abs(min_W1_W2*t/2/pi/r*stepsPerRevolution);

    float W1_star, W2_star, L1_star, L2_star;

    if (abs(W1) > abs(W2))
    {
       for (j = 0; j < round(n_min) ; j++)
       {
          motor1.step(round(alpha), direction1, DOUBLE);
          motor2.step(1, direction2, DOUBLE);  
       } 
       
       W2_star = round(n_min)*2*pi*r/t/stepsPerRevolution;
       L2_star = L2 + d2 * W2_star * t;
       
       W1_star = round(alpha)*W2_star;
       L1_star = L1 + d1 * W1_star * t; 

       //Serial.println("Reached to:");
       //Serial.print("L1_star=");
       //Serial.println(L1_star);
       //Serial.print("L2_star=");
       //Serial.println(L2_star);
       
       x = returnsX(A, c, L1_star, L2_star);
       y = returnsY(A, B ,c, d, L1_star, L2_star);

       //Serial.print("x_star=");
       //Serial.println(x);
       //Serial.print("y_star=");
       //Serial.println(y);
    }
    else if (abs(W1) < abs(W2))
    {
       for (j = 0; j < round(n_min) ; j++)
       {
         motor1.step(1, direction1 , DOUBLE); 
         motor2.step(round(alpha), direction2, DOUBLE);
       }
       
       W1_star = round(n_min)*2*pi*r/t/stepsPerRevolution;
       L1_star = L1 + d1 * W1_star * t;
       
       W2_star = round(alpha)*W1_star;
       L2_star = L2 + d2 * W2_star * t; 

       //Serial.println("Reached to:");
       //Serial.print("L1_star=");
       //Serial.println(L1_star);
       //Serial.print("L2_star=");
       //Serial.println(L2_star);
    
       x = returnsX(A, c, L1_star, L2_star);
       y = returnsY(A, B, c, d, L1_star, L2_star);

       //Serial.print("x_star=");
       //Serial.println(x);
       //Serial.print("y_star=");
       //Serial.println(y);
    }
    else if(abs(W1) == abs(W2))
    {
       for (j = 0; j < round(n_min) ; j++)
       {
          motor1.step(1, direction1, DOUBLE); 
          motor2.step(1, direction2, DOUBLE);
       }
       
       W1_star = round(n_min)*2*pi*r/t/stepsPerRevolution;
       L1_star = L1 + d1 * W1_star * t;
       
       W2_star = W1_star;
       L2_star = L2 + d2 * W2_star;

       //Serial.println("Reached to:");
       //Serial.print("L1_star=");
       //Serial.println(L1_star);
       //Serial.print("L_2star=");
       //Serial.println(L2_star);

       x = returnsX(A, c, L1_star, L2_star);
       y = returnsY(A, B, c, d, L1_star, L2_star);

       //Serial.print("x_star=");
       //Serial.println(x);
       //Serial.print("y_star=");
       //Serial.println(y);
      
    }
     //Serial.println("****************");
  }
  if (lastServoState != PASSING)
    toggleServo(lastServoState);
  // close the file:
  myFile.close();
}else {
// if the file didn't open, print an error:
Serial.println("error opening test.txt");
}
}
void loop()
{
  // put your main code here, to run repeatedly:

}
